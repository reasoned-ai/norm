
"""
Type Declaration
"""

# Declare relation
test:: (a:String, b:Integer)

# Atomic Declaration
atomic test:: a: String

# Declare function
test:: a: String -> Integer

test:: a: String -> b: Integer

test:: a: Person -> (b: Page, c: Topic)

# Declare a higher order relation
summary:: a: [String] -> String

# Subtype declaration
programmer:: Person fast_on (languages: [Language])

# Atomic definition
atomic
fast_on:: (time_per_line: Time)
 := time_per_line < 1s

Language:: String
 := "Javascript" | "Python" | "Java"


"""
Import Export
"""

# Export type
export test$AWeq23 as tt to norm.test

atomic export test to norm.test

# Import type
import norm.test.test$AWeq23 as tt

from norm.test import test$AWeq23

atomic import norm.test as tt

"""
Add/Update data
"""

# constant construction
test := 'sfs', 4 -> 6
      | 'fff', 1 -> 7

# evaluation construction
test('aa', 6) == 9

# overwrite data
test &= 'sfs', 4 -> 9

# delete data
test &= !('sfs', 4)

"""
Python Code
"""

# bind a python code
utcnow := {
    from datetime import datetime
    datetime.utcnow
}


test &= u2 = utcnow()

test(a: Integer) := { pandas.read_csv("sfsfsf.csv") }

test |= { pandas.read_csv("sfsfsf.csv") }

"""
Evaluation
"""

# create a default object
test()

# create an object
test('aa', 6)

# same as the above
test('aa', b=6)

# query the data where b=6
test(b=6)?

# same as the above
test(b==6)?

# query all data
test?

# retrieve the default object
test()?

# query for a in all data
test(a?)

# query for a and b in all data
test(a?, b?)

# query for b in case a='sfs'
test(a='sfs', b?)

test(a like 's'?, b > 3)

"""
Access
"""

# namespace
academic.spider.actor.name

# subtypes
measurement.distance

# evaluation
"sfsfs".test.b == test("sfsfs", b?)

test.mean == mean(test?)


"""
Assignment
"""

# right to left language
test_a, test_b = test(a like 's'?, b > 3)

# left to right language
test(a like 's'?, b > 3) as test_a, test_b

# dynamic variables (pivoting)
p = ['s', 'sf', 'aa'] & extract(test.a, p) as f'pattern_{p}'

"""
Draw Distribution
"""
test := a ~ gaussian(mu=2, gamma=0.1)

"""
Sorting
"""
test? & a.desc & b.asc

"""
Quantified Logic
"""
for a, b in test:
     a.mean as a_mean
   & a.max  as a_max
   & b.mean as b_mean

for each b in test:
  exist a in test:
    a.sum > 3

# Mixed aggregation and regular conditions
test.a.mean as a_mean and
for b in test:
  exist a in test:
    a > a_mean

test.a.mean as a_mean and test.a.std as a_std and
for a in test:
    abs(a - a_mean) < 2 * a_std

"""
Slicing
"""
test[1]

test[3:7]

test[:9]

test[2:9:2]

test[:-2]


"""
Time Windowing
"""
moving_average = test.rolling(10m).mean


"""
Anti-join
"""

  StarIn(star_name?, movie_title?)
& Movie(title=movie_title, studio_name?, movie_year>=2000)
& not Star(name=star_name, birth_date==1960)
& return movie_title, studio_name


"""
Higher order logic
"""
atomic Pattern:: e: Event -> String

EmergingPattern:: (event    : Event,
                   pattern  : [Pattern],
                   interval : Time Parameter = 10m,
                   threshold: Integer Parameter = 10)
:= event.rolling(interval).pattern.unique.count > threshold

windows_ip:: Pattern
:= e.name == "ip is not reachable" and
   e.managed_entity.os == "windows" and
   return e.managed_entity.ip

EmergingPattern(event=event,
                pattern=windows_ip,
                interval=10m,
                threshold=20)

port_exception:: Pattern
:= e.name == "port exception" and
   return e.managed_entity.port

EmergingPattern(event=event,
                pattern=port_exception,
                interval=30m,
                threshold=100)

"""
Switch block
"""

    a > 3 => return 'larger than 3'
and a > 1 => return 'larger than 1'
otherwise    return 'smaller than or equal to 1'