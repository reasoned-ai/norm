TestCase1::

# Declare a relation
Test::
a: String

# Declare function
Test::
a: String,
-> Integer

Test::
a: String,
-> b: Integer

Test::
a: Person,
-> (
  b: Page,
  c: Topic
)

# List
Summarize::
a: [String],
-> String

# Subtype
Programmer::
Person

# Supertype
Language::
| Javascript
| Python
| Java

FluentOn::
write_lines_per_second: Integer > 10

# Combinator
Programmer::
Person,
FluentOn,
language: Language


"""
data
"""

# new data
Test
= 'sfs' , 4, -> 6
| 'fff' , 1 ,-> 7

# increment by overwrite
Test
&= 'sfs', 4, -> 9

# increment by append
Test
|= 'sfs', 4 ,-> 7,  # should be no effect


# delete data
Test
&= !('sfs', 4, -> 9), # mark as negative


"""
Python Code
"""
UTCNow::
-> Datetime,
{{
    from datetime import datetime
    return datetime.now()
}}

u2 = UTCNow.Sample(100)

"""
Evaluation
"""

# query all data
Test

# query one default object
Test()

# query an object
Test('aa', 6)

# same as the above
Test('aa', b=6)

# query the data where b=6
Test(b=6)

# same as the above
Test(b==6)

# query for a in all data
Test.a

# query for b in case a='sfs'
Test(a='sfs').b

# query on complicated logic
Test(
    a like 's',
    b > 3,
    a + b < 4
),

"""
Assignment
"""

# right to left language
atest = Test(a like 's', b > 3)

# left to right language
test_a, test_b = test(a like 's', b > 3)

# dynamic variables (pivoting)
for p in 's' | 'sf' | 'aa' (
  pattern_{p} = Test.a.Match(p)
)

"""
Sorting
"""
Test.Desc(a).Asc(b)

"""
Quantified Logic
"""
for a, b in Test(
     a_mean = a.Mean,
     a_max = a.Max,
     b_mean = b.Mean
)

Test(
  for any b(
    exist a(
      c.Sum > 3
    )
  )
)

# Mixed aggregation and regular conditions
a_mean = Test.a.Mean,
for any b in test(
  exist a in test(
    a > a_mean
  )
)

a_mean = test.a.Mean,
a_std = test.a.Std,
for a in test(
    abs(a - a_mean) < 2 * a_std
)

"""
Slicing
"""
test[1]

test[3:7]

test[:9]

test[2:9:2]

test[:-2]


"""
Time Windowing
"""
moving_average = Test.rolling(10m).mean


"""
Anti-join
"""

21stCenturyMoviesWithStarsBornNotIn1960::
a = Star(birth_date!=1960),
m = Movie(
  title=a.name.StarIn.movie_title,
  year>=2000
),
-> (
  movie_title: String = m.movie_title,
  studio_name: String = m.studio_name
)


"""
Higher order logic
"""
Pattern:: events: [Event], -> String

UnreachableWindowsIP::
Pattern,
exist e in events(
  e.name == "ping is not reachable" &
  e.managed_entity.os == "windows"
) -> e.managed_entity.ip

PortException::
Pattern,
exist e in events(
  e.name == "port exception"
) -> e.managed_entity.port

EmergingPattern::
event    : Event,
pattern  : Pattern,
period : TimeInterval,
threshold: Integer,
.Parameter(period, 1 min),
.Parameter(threshold, 20),
event.Past(period).pattern.Unique.Count > threshold

EmergingPattern(
  event=event,
  pattern=UnreachableWindowsIP | PortException,
  period=10 min
)

"""
Switch block
"""
a: Integer, -> String,
| a > 3 -> 'larger than 3'
| a > 1 -> 'between 1 and 3'
| -> 'smaller than or equal to 1',


"""
Tail recursion
"""
factorial::
n: Integer, -> Integer,
| n == 1 -> 1
| n > 1 -> n * factorial(n - 1),


"""
Transformer
"""

Transformer::
s: [Word], -> [Word],
depth: Integer,
head: Integer,
.parameter(head, 4),
.parameter(depth, 10),
| depth == 0 -> s
| depth > 0 -> (
  for w in s(
    Transformer(
      s=s,
      depth=depth - 1,
      head=head
    ) -> w,
  )
),


"""
Default risk analysis
"""
DefaultRisk::
person: Person,
item: Product,
-> String,
| exist account in person.Account(
    account.mean > 200$,
    account.duration > 15 month
  )
  & person.Credit.Mean < 3900$
  & person.employed
  & person.Residence.Latest.duration > 2.5 year
  & item.IsA.Car
  & item.color != "red" -> "low"
| -> "high"

